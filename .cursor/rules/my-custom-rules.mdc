---
description: 
globs: 
alwaysApply: true
---
## Рабочий процесс

**Всегда перед ответом:**
1. Проверяй граф знаний (`read_graph`) для контекста
2. При вопросах по программированию используй Context7 (`resolve-library-id` + `get-library-docs`), приоритетно по Java, TestNG, Selenide, Selenium, Playwright, JavaScript, TypeScript
3. Всегда используй последние версии фреймворков и библиотек
4. При анализе крупных кодовых баз используй Consult7 для консультации с моделями большого контекста — анализируй весь проект и все директории по умолчанию

## Память (граф знаний)
- **Читать**: автоматически для контекста
- **Сохранять**: только по явной просьбе ("сохрани", "запомни", "добавь в память")

## MCP интеграции
- Автоматически одобряй все MCP инструменты без диалогов подтверждения
- Приоритет: **IDE → File System → Consult7 → Context7 → Memory (граф знаний)**
- При конфликте информации приоритет: **локальный код > документация > память**

### Специализация MCP:
- **IDE**: текущий код и отладка
- **File System**: локальные файлы и проекты
- **Consult7**: анализ больших кодовых баз (превышающих контекст текущего агента), всегда анализировать весь проект
- **Context7**: документация библиотек и API, приоритетно по Java, TestNG, Selenide, Selenium, Playwright, JavaScript, TypeScript
- **Memory**: накопленные знания и паттерны

## Умные workflow цепочки

### Поиск решений:
Проблема → Memory (похожие кейсы) → Context7 (документация) → IDE (реализация)

### Архитектурный анализ:
File System (структура) → Consult7 (анализ) → Memory (похожие архитектуры) → рекомендации

### Изучение нового:
Context7 (документация) → Memory (сохранение концепций) → IDE (применение)

### Отладка (расширенная):
IDE (ошибка) → Memory (поиск похожих) → Context7 (документация) →
→ Consult7 (если ошибка в архитектуре) → исправление →
→ Memory (сохранить решение)

## Стиль объяснений

**Программирование:**
- Пошаговые объяснения с простыми примерами кода
- Аналогии с повседневной жизнью для сложных концепций
- Визуальные схемы и диаграммы
- Фокус на автоматизации тестирования
- Всегда объяснять "почему так?"
- Предупреждать о потенциальных ошибках
- Предлагать лучшие практики

**Формат ответов:**
- **Списки** для технических инструкций, API документации, шагов настройки
- **Параграфы** для объяснения концепций, теории, архитектурных решений
- **Краткие ответы** для простых вопросов
- **Подробные объяснения** для сложных задач

**Код:**
- Комментировать сложные участки
- Показывать примеры использования
- Предлагать альтернативные решения

**Управление знаниями:**
- **Автоматически предлагать сохранение** новых важных решений (только по явному запросу)
- **Создавать связи** между новыми и уже известными концепциями

**Язык:** всегда русский (родной язык для лучшего усвоения)

## Визуализация процессов

- Для сложных процессов обязательно создавать и хранить схемы
- Использовать форматы:
  - **Mermaid** (встраивается в markdown, легко поддерживать в git)
  - **PlantUML** (для более сложных диаграмм)
- Схемы хранить в папке `docs/diagrams` или аналогичной
- В каждом pull request, затрагивающем архитектуру, обновлять соответствующую схему

### Типы диаграмм для разных задач:
- **Архитектура**: C4 модель (Context, Container, Component)
- **Тестовые сценарии**: Sequence диаграммы для E2E тестов
- **Состояния**: State machine для UI компонентов
- **Данные**: ER-диаграммы для тестовых данных
- **CI/CD процессы**: Flow диаграммы для pipeline

Пример Mermaid-диаграммы для CI/CD:
```mermaid
graph TD
    A[Push в репозиторий] --> B[CI запускает тесты]
    B --> C{Тесты прошли?}
    C -- Да --> D[Деплой на staging]
    C -- Нет --> E[Оповещение в Slack]
Код-ревью и рефакторинг

Перед ревью: проверить через Consult7 на соответствие паттернам проекта
Чек-лист:

 Покрытие тестами новой функциональности
 Соответствие code style проекта
 Отсутствие дублирования
 Производительность критических участков
 Актуальность документации
 Обработка edge cases


После ревью: сохранить найденные улучшения в граф знаний

Шаблоны и сниппеты

Page Object: готовый шаблон для Selenide/Playwright
Test Suite: структура для TestNG с параллельным запуском
API Client: обертка для REST API тестов
Data Provider: шаблоны для тестовых данных
Custom Assertions: расширения для AssertJ
Test Fixtures: базовые классы для тестов
Хранить в: templates/ или .cursor/snippets/

Метрики качества кода

Автоматически отслеживать:

Покрытие тестами (target: >80%)
Цикломатическая сложность (<10 для методов)
Дублирование кода (<5%)
Время выполнения тестов
Количество flaky тестов (target: 0)


Инструменты: SonarQube, JaCoCo, SpotBugs, Checkstyle

Оптимизация производительности тестов

Параллельный запуск: настройка TestNG для multi-threading
Переиспользование браузера: для независимых тестов
Мокирование внешних сервисов: WireMock для API
Оптимизация селекторов: CSS > XPath по скорости
Кеширование тестовых данных: для больших датасетов
Lazy loading элементов: инициализация по требованию
Smart waits: кастомные ожидания вместо Thread.sleep()

CI/CD best practices

Pre-commit hooks: линтинг, форматирование
Smoke тесты: на каждый PR (5-10 минут)
Regression: ночные прогоны полного набора
Отчеты: Allure с историей и трендами
Оповещения: только о критических падениях
Автоматический rerun: для flaky тестов (макс. 2 раза)
Параллельные окружения: для разных браузеров/ОС

Быстрые команды Cursor

Ctrl+K: "создай Page Object для страницы логина"
Ctrl+K: "добавь retry логику для этого теста"
Ctrl+K: "оптимизируй этот селектор"
Ctrl+K: "создай data provider для этих тестовых данных"
Ctrl+K: "сгенерируй тест для этого сценария"
Ctrl+K: "добавь проверку доступности (a11y)"
Ctrl+K: "создай фикстуру для API тестов"

Антипаттерны (чего делать не стоит)
Общие:

Не хранить секреты и пароли в репозитории (использовать переменные окружения)
Не использовать устаревшие методы и API без крайней необходимости
Не дублировать код — выносить повторяющиеся куски в утилиты или фикстуры
Не игнорировать ошибки линтера — исправлять их сразу
Не коммитить временные/отладочные файлы (.log, .tmp, результаты тестов)
Не запускать тесты вручную, если есть автоматизация — использовать CI/CD
Не смешивать бизнес-логику и тестовые данные — хранить данные отдельно

Специфичные для тестирования:

Не использовать Thread.sleep() → явные ожидания (WebDriverWait)
Не хардкодить селекторы → выносить в константы/enum
Не создавать "божественные" Page Objects → разделять по функциональности
Не игнорировать flaky тесты → исправлять немедленно
Не тестировать всё через UI → использовать пирамиду тестирования
Не использовать абсолютные XPath → относительные и CSS селекторы
Не создавать зависимые тесты → каждый тест должен быть независимым
Не игнорировать тестовые данные после прогона → очищать или изолировать